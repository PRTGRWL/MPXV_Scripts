// main js for public zone pages

// CAUTION script should not be async / defer (should be regular script in head), as init_tabs method should be called by in-lined script right after body start (to have tabs right from beginning...)
// (besides init_tabs) initializes itself after DOMContentLoaded

const Glob = {
    "prefix"   : "", // e.g. "" or "/prime"
    "announce" : "" // CAUTION: do not commit msg here, just add announce txt when needed on public "running" servers!
        // e.g.: "Scheduled DOWNTIME: due to network maintenance, this service will not be available January 11, 2023 from 11am to 2pm CET. Thank you for your patience."
};

const isMobile = navigator.userAgent.match(/mobile/i ) !== null;


document.addEventListener( "DOMContentLoaded",
    function() {
        document.removeEventListener( "DOMContentLoaded", arguments.callee, false);
        initz( document.body.id );
    },
    false
); // when dom loaded: initz


function initz() { // (when dom loaded) initialize all js systems
    finalize_tabs();
    injectAnnounce();

    initInlineSVGs();
    initLinkPreview();

    initFolding();
    initAutoComplete();

    initSliders();
    initDataTables();
    initCharts();
    initPDBs();

    initUniProtForms();
}


function injectAnnounce() {
    if ( Glob.announce ) {
        document.getElementById( "announce" ).appendChild(document.createTextNode(Glob.announce))
    }
}


/* ------ autocomplete (copied form core.js so that zone.js could be use standalone) ------ */


function initAutoComplete() {
    const elems = document.querySelectorAll( '[data-suggest-path]' );
    for( const elem of elems ) {
        prepareElemAutoComplete( elem );
    }

}


function prepareElemAutoComplete( elem, sid ) {
    const parent = elem.parentNode; // yes parent (likely form) needed: menu will be attached to parent, after target (likely input) elem
    elem.setAttribute( "data-public-sid", sid );
    elem.onmouseout = function( ev ) { ev.stopPropagation() };
    elem.autocomplete = "off"; // turn off browser input elem "auto complete"!
    elem.addEventListener(   "keyup",   startElemAutoComplete );
    elem.addEventListener(   "keydown", autoCompleteArrows );
    parent.addEventListener( "keyup",   function( ev ) {
        const k = ev.key.toLowerCase();
        if ( k === 'escape' || k === 'esc' ) { exitAutoComplete( this ) }
    } );
}


function startElemAutoComplete( ) { // onkeyup handler for an auto complete element
    const target = this;
    const parent = this.parentNode;
    const prefix = target.value;
    if ( prefix.length > 2 && prefix.length !== Number( target.getAttribute( "data-prev-size" ) ) ) { // if value has changed send txt for suggestion
        get( this.getAttribute( "data-suggest-path" )+"/"+target.value, this.getAttribute( 'data-public-sid' ) ).then( // request suggestions
            function( str ) { // upon suggestion arrival
                exitAutoComplete( parent ); // rm previous suggestion
                const ul     = document.createElement( 'ul' ); // add list
                ul.style     = "cursor:pointer";
                ul.className = "suggest";
                const lines  = cleanHTML( str ).split( /\r?\n/ );
                if ( str !== "" ) {
                    lines.forEach( // for each suggestion line add list line
                        function( line ) {
                            const txt       = line.replace( /<[^>]+>/gm, '' );
                            const li        = document.createElement( 'li' );
                            li.className  = "suggest";
                            li.innerHTML  = line;
                            li._value     = txt;
                            li.addEventListener( "mouseover", function( ) { focusMenuItem( this ) } );
                            li.addEventListener( "mouseout",  function( ) { unFocusMenuItem( this ) } );
                            li.addEventListener( "click", function( ) {
                                focusMenuItem( this );
                                target.value = txt; // yes works with both for input and textarea
                                this._focus = true;
                                target.focus();
                            } );
                            li.addEventListener( "dblclick", function( ) {
                                target.value = txt;
                                target.focus();
                                parent.submit();
                            } );
                            ul.appendChild( li ); // add list line to list
                            ul.addEventListener( "mouseleave", function( ) { exitAutoComplete( parent ) } );
                        }
                    );
                    parent.appendChild( ul ); // add list to parent of text/editable "field"
                }
            }
        );
    }
    else if ( target.value.length < 3 ) exitAutoComplete( parent );
    target.setAttribute( "data-prev-size", prefix.length );
}


function exitAutoComplete( parent_of_suggest_elem ) {
    const uls = parent_of_suggest_elem.getElementsByTagName( "ul" );
    if ( uls.length > 0 ) parent_of_suggest_elem.removeChild( uls[0] );
}


function unFocusParentMenu( li ) {
    const lis = li.parentNode.childNodes;
    for ( const li of lis ) { li._focus = false; li.className = "suggest" }
}
function focusMenuItem( li ) {
    unFocusParentMenu( li );
    li._focus    = true;
    li.className = "suggest_focus";
}
function unFocusMenuItem( li ) {
    unFocusParentMenu( li );
    li._focus    = false;
    li.className = "suggest";
}


function autoCompleteArrows( ev ) {
    const ul_menu = this.parentNode.lastChild;
    if ( ul_menu && ( ev.keyCode === 38 || ev.keyCode === 40 ) ) {
        const lis  = ul_menu.childNodes;
        const m    = lis.length;
        let ifocus = -1;
        for( let i=0 ; i<m; i++ ) {
            const li = lis[ i ];
            if ( li._focus === true ) { ifocus = i; break; }
        }
        const old_focus_li = lis[ ifocus ];
        let   new_focus_li = old_focus_li;
        if (      ev.keyCode === 38 && ifocus > 0 )       new_focus_li = lis[ ifocus - 1 ]; // up
        else if ( ev.keyCode === 38 && ifocus === 0 )     new_focus_li = lis[ m - 1 ];
        else if ( ev.keyCode === 40 && ifocus < m - 1 )   new_focus_li = lis[ ifocus + 1 ]; // down
        else if ( ev.keyCode === 40 && ifocus === m - 1 ) new_focus_li = lis[ 0 ];
        if ( new_focus_li !== old_focus_li ) { // move focus li
            if ( old_focus_li ) {
                old_focus_li.className = 'suggest';
                old_focus_li._focus    = false;
            }
            new_focus_li.className = 'suggest_focus';
            new_focus_li._focus    = true;
            this._value = new_focus_li._value;
        }
        ev.preventDefault();
    }
    else if ( this._value && ev.key.toLowerCase() === 'enter' ) {
        this.value = this._value;
        this.focus();
        if ( this.parentNode.tagName.toLowerCase() === 'form' ) this.parentNode.submit();
    }
}


/* ------ sequence selection & uniprot forms ------ */ // used by handlers defined in initz


function initUniProtForms() {
    // init uniprot list view form elements
    let elems = document.getElementsByClassName( "_form_sel_all" );
    for( const elem of elems ) {
        elem.addEventListener( 'click', function( ) {
            const form = this.parentNode;
            for( const q of form.q ) { // <input>s (type="checkbox") should have name="q"
                q.checked = true
            }
        } )
    }
    elems = document.getElementsByClassName( "_form_sel_none" );
    for( const elem of elems ) {
        elem.addEventListener( 'click', function( ) {
            const form = this.parentNode;
            for( const q of form.q ) {
                q.checked = false
            }
        } )
    }
    elems = document.getElementsByClassName( "_form_action_align" );
    for( const elem of elems ) {
        elem.addEventListener( 'click', function( ) {
            var form     = this.parentNode;
            form.method = 'get';
            form.action = 'https://www.uniprot.org/align';
            form._minsel = 2;
            addInputIds2UniProtQueryForm( form );
            // as elem is input.type = "submit", click will trigger form submission
        } )
    }
    elems = document.getElementsByClassName( "_form_action_retrieve" );
    for( const elem of elems ) {
        elem.addEventListener( 'click', function( ) {
            var form    = this.parentNode;
            form.method = 'get';
            form.action = 'https://www.uniprot.org/id-mapping';
            form._minsel = 1;
            addInputIds2UniProtQueryForm( form );
            // as elem is input.type = "submit", click will trigger form submission
        } )
    }
    elems = document.getElementsByClassName( "_form_action_map" );
    for( const elem of elems ) {
        elem.addEventListener( 'click', function( ) {
            var form    = this.parentNode;
            form.method = 'get';
            form.action = 'https://www.uniprot.org/id-mapping?from=UniProtKB_AC-ID&to=EMBL-GenBank-DDBJ';
            const to = document.createElement( 'input' );
            to.type  = "hidden";
            to.name  = 'to';
            to.value = 'EMBL-GenBank-DDBJ';
            form.appendChild( to );
            form._minsel = 1;
            addInputIds2UniProtQueryForm( form );
            // as elem is input.type = "submit", click will trigger form submission
        } )
    }

    const forms = document.getElementsByClassName( "_form" );
    for( const form of forms ) {
        form.addEventListener( 'submit', function( ev ) { // add submit check on form submit
            let nsel = 0;
            for( const q of this.q ) {
                if ( q.checked ) nsel++;
            }
            if ( this._minsel && nsel < this._minsel ) ev.preventDefault(); // prevent submission if n selected element is lower than expected _minsel
        } )
    }
}


function addInputIds2UniProtQueryForm( form ) { // query for retrieve, align, map against uniprot: wants query param (with ACs, ws separated), build query param from list (inputs with q name)
    let idListString = '';
    let elems        = [];
    if ( form.q.length ) { elems = form.q } // all form (protein) checkbox input elements should have name "q" (its value should = input protein AC)
    else                 { elems = [ form.q ] }
    for( const elem of elems ) {
        if ( elem.checked ) idListString = idListString + elem.value + ',';
    }
    const inputIDs = document.createElement( 'input' );
    inputIDs.type  = "hidden";
    inputIDs.name  = 'ids';
    inputIDs.value = idListString;
    // p.s. leftover 'q' inputs (will be submitted!) not a problem
    form.appendChild( inputIDs );
    form.target = "_blank";
}




/* ------ misc ------*/


// foldable panel
function initFolding() {
    const elems = document.getElementsByClassName( "foldbutton" ); // on button or img of class foldbutton
    for( const elem of elems ) { // for each targeted button/img
        if ( elem.getAttribute( "data-target-id" ) ) {
            elem._target = document.getElementById( elem.getAttribute( "data-target-id" ) );
            elem._img    = elem.tagName === "IMG" ? elem : document.createElement( "img" ); // if not an img: create child img
            if ( elem.tagName !== "IMG" )    elem.appendChild( elem._img );
            if ( elem._target.className === 'hidden' ) elem._img.src = Glob.prefix+'/resources/images/expand.gif';
            else                                       elem._img.src = Glob.prefix+'/resources/images/collapse.gif';
            elem.addEventListener( 'click', function( ) { // add onClick
                if ( this._target.classList.contains('hidden') ) {
                    this._target.className = 'visible';
                    this._img.src = Glob.prefix+'/resources/images/collapse.gif'
                }
                else {
                    this._target.className = 'hidden';
                    this._img.src = Glob.prefix+'/resources/images/expand.gif'
                }
            } )
        }
    }
}



function s( id ) {
    document.getElementById( id ).className='tooltip';
} // !? not used in this js file (?used in html inlined handlers?)
function h( id ) {
    document.getElementById( id ).className='hidden';
} // !? not used in this js file (?used in html inlined handlers?)


/* ------ tabs (for uniprot view) ------*/


function finalize_tabs() {
    /* if js is on: after page has been loaded: build tabs based on (in page) t0-8 div... */

    const tb = document.getElementById( 'tab_bar' );
    const ul = document.createElement( 'ul' ); // create ul for list of tabs
    tb.appendChild( ul );

    let   n = 0;
    const id_base_list = [ 0, 6, 7, 8, 1, 2, 3, 4, 5 ]; // defines the order
    // 0 is core, 6, 7 uniprot views, 1-5 custom (from page content)
    for ( const i of id_base_list ) { // scan for content div#t0-8 that needs to be tab-ed
        // n.b.
        const div = document.getElementById( 't'  + i );
        if ( div ) { // div for tabbed content was found in page
            n++;
            const li     = document.createElement( 'li' ); // create li (tab)
            li.className = 'tab' + i;
            li._tid      = i;
            if ( div.firstChild && div.firstChild.nodeName === 'A' ) li._href = div.firstChild.href;
                // if any, copy target div first child link href into corresponding li "tab" itself (as _href), so it is accessible in event handlers over li (to link to that address)
                // n.b. Actually div#t6 just contains "reorder by" link and is inside #t7 ! the built tab (second one) will just point to this link (changing page in fact),
                // all other tabs (for all other div 0,1,2,3,4,5,7) just link to content within same page (un-hiding it)
            // add tab event listeners
            li.onclick = function() {
                set( this.className );
                if      ( this._tid === 0 ) window.location = cleanUrlOfAnchor();
                else if ( this._tid < 6 )   window.location = cleanUrlOfAnchor() + "#" + this.className;
                else if ( this._href )      window.location = this._href;
                else                        window.location = "#" + this.className;
            };
            li.onmouseover = function(){ this.id = 'tab_focus'; };
            li.onmouseout  = function(){ this.id = '' };

            var text = '?'; // build tab txt ...
            if      ( div.title )           text = div.title;// use tabbed content div title if any
            else if ( i===0 && !div.title ) text = 'General';

            li.appendChild( document.createTextNode(text) ); // add tab txt
            ul.appendChild(li); // add tab to tab bar
        }
    }
    if ( n>1 ) document.getElementById('tab_bar').className = 'final';  // show tab bar (if there is more than 1 tab)

}


function init_tabs() {
    /* (called at the beginning) (if js is on) will hide (via css) t>0
     tabbed div content... */
    document.body.id = 'tab0';
    // replace taball original id (then only tab0 will be shown during load)

    window.onbeforeunload = function () {  };
    // back button fix (when >=one tab is an external link: back did
    // not correctly reload previous content if on a different page!...)
    // just having an empty onbeforeunload event will cause the browser
    // to never cache the page... (without messing with Cache-Control,
    // Expires, Pragma ... http header)
    //
    // n.b. if tab + in place editing are used on the same page:
    //      this onbeforeunload will be overwritten (but it's ok)...

    // reading anchor url and jumping to corresponding tab
    var anchor = document.location.hash.substring(1);
    if ( anchor ) set( anchor );
}


function set(id) { /* set active tab (id = tab0-7) */
    document.body.id = id;// set tab
    // p.s. css trick: by default div#t<n(0-7)> are hidden (display:none)
    //      but div#t<n> when <n> is matching body#tab<n> (e.g. body#tab6 div#t6)
    //      are visible (display: block), so once the body id is set, the
    //      matching div#t<n> becomes visible.
}


function cleanUrlOfAnchor() {
    return ( window.location.toString().split("#")[0] );
}



// svg inlining

function initInlineSVGs( root0 ) {
    // replace all inline_svg (img) by injected src svg! + enrich svg based on id "codes" + add save as "button"
    const root = root0 ? root0 : document.getElementById( "wiki" );
    for ( let img of document.querySelectorAll( "img.inline_svg" ) ) {
        get( img.src ).then (
            function( str ) {
                const container = document.createElement( "div" );
                container.innerHTML = cleanHTML( str );
                container.className = "_svg_holder";
                container.title = "Use mouse scroll wheel to zoom; Double click to toggle full width view";
                const inlined_svg = container.querySelector( "svg" );
                const w = inlined_svg.getAttribute( "width" );
                const h = inlined_svg.getAttribute( "height" );
                container.style.width  = w; inlined_svg.removeAttribute( "width" );
                container.style.height = h; inlined_svg.removeAttribute( "height" );
                // yes, not using img.outerHTML = , as we want a handle on the replacement to copy classList & id
                if ( inlined_svg ) {
                    container.replaceChildren( inlined_svg ); // inlined_svg already child of container, but get rid of extra comments
                    for ( const c of img.classList.entries() ) { inlined_svg.classList.add( c[1] ); } // copy css classlist from original image
                    if ( img.id ) inlined_svg.id = img.id; // !?
                    enrichAiSvg( inlined_svg );
                    img.replaceWith( container );
                    initLinkPreview( inlined_svg, 500 );  // add link preview within new inlined sSVG! (could not be done from root document should start at inlened_svg (shadow svg dom)
                    container._ori_parent       = container.parentElement;
                    container._ori_next_sibling = container.nextElementSibling;
                    const r = container.getBoundingClientRect();
                    container._ori_top = r.top + "px";

                    // add save as link (as inline svg is not like img that have right-click save as)
                    const s = document.createElement( "a" );
                    //s.innerHTML = "&#8615;";
                    const i = document.createElement( "img" );
                    i.src  = Glob.prefix + "/resources/images/arrow_down_1.png";
                    s.appendChild( i );
                    s.title     = "Save SVG Image As";
                    s.className = "_save_as";
                    s.download  = inlined_svg.id.toLowerCase()+"_image.svg";
                    s.target    = "_blank";
                    s.href      = ".";
                    s.addEventListener( 'click', function( ev ) { saveSvg( inlined_svg, s ) } );
                    container.appendChild( s );

                    // add toggle full width view upon dblclick
                    if ( !isMobile ) container.addEventListener( 'dblclick', function(ev) {
                        container.classList.toggle( "full_width" );
                        inlined_svg.style.width = "100%"; // fixes problem with safari
                        if ( container.classList.contains( "full_width" ) ) { // expand svg (container)
                            container.style.top = container._ori_top;
                            let anchor = document.querySelector( "div.page" );
                            if ( anchor && anchor !== container.parentElement ) anchor.appendChild( container ); // move element to ~top div.page (to be not size constrained by eventual parent e.g. when within image slider)
                        }
                        else { // put svg (container) back into place
                            container.style.top = null;
                            if ( container._ori_parent && container._ori_parent !== container.parentElement  ) {
                                if ( container._ori_next_sibling ) container._ori_parent.insertBefore( container, container._ori_prev_sibling );
                                else                               container._ori_parent.appendChild( container );
                            }
                        }
                    } );
                }
            }
        ) //.catch ( function() { img.title = "svg inlining not available"; } );
    }

}

function saveSvg( svg, lnk ) {
    const data  = ( new XMLSerializer() ).serializeToString( svg );
    const sblob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' } );
    const url   = URL.createObjectURL( sblob );
    lnk.setAttribute( 'href', url )
}

function enrichAiSvg( svg ) {
    // Bypass AI (Adobe Illustrator), svg import/export limitations!
    // as svg are made via Adobe Illustrator, add links and special attributes via id (only preserved attribute layer name) "codes" (won't work with full url as many chars are cleaned)
    for ( let grp of svg.querySelectorAll( "[id^=uniprot]" ) ) { // enrich (g) with id="uniprot:<uniprotAC>": add link around first child
        const upac  = grp.id.slice( 8 );
        //const uplnk = document.createElement( "a" );
        const uplnk = document.createElementNS( "http://www.w3.org/2000/svg", "a" );
        uplnk.href.baseVal="https://www.uniprot.org/uniprotkb/"+upac+"/entry";
        uplnk.target.baseVal = "_blank";
        uplnk.appendChild( document.createElementNS( "http://www.w3.org/2000/svg", "title" ) ); // add empty title to have no tooltip when mousing over element with link (as will have popup!)
        uplnk.append( ...grp.children ); // move all target children under newly created link
        grp.append( uplnk ); // add created link as target child
    }
    for ( let grp of svg.querySelectorAll( "[id^=viralzone]" ) ) { // enrich (g) with id="viralzone:<pageid>": add link around first child
        const vzac  = grp.id.slice( 10 );
        const vzlnk = document.createElementNS( "http://www.w3.org/2000/svg", "a" );
        vzlnk.href.baseVal   = Glob.prefix+"/"+vzac; // relative link within same site
        vzlnk.target.baseVal = "_blank";
        vzlnk.appendChild( document.createElementNS( "http://www.w3.org/2000/svg", "title" ) ); // add empty title to have no tooltip when mousing over element with link (as will have popup!)
        vzlnk.append( ...grp.children ); // move all target children under newly created link
        grp.append( vzlnk ); // add created link as target child
    }
    for ( let grp of svg.querySelectorAll( "[id^=rhea]" ) ) { // enrich (g) with id="rhea:<rheaAC>": add link around first child
        const rheaac  = grp.id.slice( 8 );
        const rhealnk = document.createElementNS( "http://www.w3.org/2000/svg", "a" );
        rhealnk.href.baseVal   = "https://www.rhea-db.org/rhea/"+rheaac
        rhealnk.target.baseVal = "_blank";
        rhealnk.appendChild( document.createElementNS( "http://www.w3.org/2000/svg", "title" ) ); // add empty title to have no tooltip when mousing over element with link (as will have popup!)
        rhealnk.append( ...grp.children ); // move all target children under newly created link
        grp.append( rhealnk ); // add created link as target child
    }
    // highlight & css enrichments:
    for ( let grp of svg.querySelectorAll( "[id^=highlight]" ) ) { // enrich (g) with id="highlight:<svg_id>:<elem_to_highlight_id>" (just adding event handlers)
        const svg_id               = grp.id.slice( 10 ).replace( /:.+$/, "" );
        const elem_to_highlight_id = grp.id.slice( 10 + svg_id.length + 1 );
        grp.addEventListener( "mouseenter", function( ev ) {
            const svg = document.getElementById( svg_id );
            if ( svg ) {
                const elem_to_highlight = svg.getElementById( elem_to_highlight_id );
                if ( elem_to_highlight ) { elem_to_highlight.classList.add( "svgselect" ); }
            }
        } );
        grp.addEventListener( "mouseleave", function( ev ) {
            const svg = document.getElementById( svg_id );
            if ( svg ) {
                const elem_to_highlight = svg.getElementById( elem_to_highlight_id );
                if ( elem_to_highlight ) { elem_to_highlight.classList.remove( "svgselect" ); }
            }
        } );
    }
    for ( let grp of svg.querySelectorAll( "[id^=css]" ) ) { // enrich (g) with id="css:<className>"
        const cname  = grp.id.slice( 4 ).replace( /_\w+$/, "" );
        grp.classList.add( cname ); // e.g. colorshift ... together with in css .colorshift:hover ... = adds hover "behavior" on element
    }
    // add zoom handler
    svg._ori_viewbox = svg.getAttribute( "viewBox" );
    svg.addEventListener( 'mousemove', function(ev) { // record mouse pos for zoom (and more...)
        svg._mouse_x = ev.clientX;
        svg._mouse_y = ev.clientY;
        if ( svg._active_popup && svg._popup_drag ) { // if here = popup mouse was lost during move (too fast, outside of popup!), move it here!...
            const pop = svg._active_popup;
            pop.style.cursor = "move";
            if ( ev.which === 1 ) {
                event.preventDefault();
                pop.style.left = (ev.clientX + pop._offset_x) + 'px';
                pop.style.top  = (ev.clientY + pop._offset_y) + 'px';
            }
        }
    } );
    svg.addEventListener( 'wheel', function(ev) { // handle ZOOM
        const scale = ev.deltaY < 0 ? 1.08 : 0.92;
        const viewbox = _scaleViewBox( svg, scale, svg._mouse_x, svg._mouse_y );
        if ( true ) { // if ( ev.shiftKey ) {
            svg.setAttribute( "viewBox", viewbox );
            if ( svg._active_popup ) {
                svg._active_popup.classList.add( "hidden" );
                deSelectAll( grps, list );
            }
        }
        ev.preventDefault();
        ev.stopPropagation();
    });
    document.addEventListener( "keydown", function( ev ) {
        if ( ev.keyCode === 27 ) _resetViewBox( svg );
    } );
}

// svg zoom
function _viewport2SVG(x, y, svg ) { // convert vp mouse coordinates to svg ones
    const vp_pt = svg.createSVGPoint();
    vp_pt.x = x; vp_pt.y = y;
    const svg_pt = vp_pt.matrixTransform( svg.getScreenCTM().inverse() );
    return( { x: svg_pt.x, y: svg_pt.y } );
}

function _scaleViewBox(svg, scale, cx, cy ) {
    const pointer  = _viewport2SVG( cx, cy, svg ); // convert vp mouse coordinates to svg ones
    const ori_vba  = svg._ori_viewbox.split( ' ' );
    const vba      = svg.getAttribute( "viewBox" ).split( ' ' );
    const minx_current  = Number(vba[0]); const miny_current   = Number(vba[1]);
    const width_current = Number(vba[2]); const height_current = Number(vba[3]);
    const rx = ( pointer.x - minx_current ) / width_current;
    const ry = ( pointer.y - miny_current ) / height_current;
    const minx = pointer.x - ( width_current / scale * rx );
    const miny = pointer.y - ( height_current / scale * ry );
    if ( width_current / scale > Number(ori_vba[2]) || height_current / scale > Number(ori_vba[3])) { // zoom out max rechead
        if ( Math.abs(minx_current) < 10.0 && Math.abs(miny_current) < 10.0 ) return( svg._ori_viewbox ); // almost centered: put back ori viewbox
        else { // view has shifted: bring it closer to center (& dezoom slowly)
            const ori_vba = svg._ori_viewbox.split( ' ' );
            const width_ori = Number(ori_vba[2]); const height_ori = Number(ori_vba[3]);
            const w0 = width_current*1.01;  const w = w0 > width_ori  ? width_ori  : w0;
            const h0 = height_current*1.01; const h = h0 > height_ori ? height_ori : h0;
            svg._last_viewbox = (minx_current/1.4)+" "+(miny_current/1.4)+" "+w+" "+h;
            return( svg._last_viewbox );
        }
    }
    if ( scale > 1.0 && ( width_current < 40.0 || height_current < 40.0 ) ) return( svg._last_viewbox ); // zoom in max reached
    svg._last_viewbox = minx+" "+miny+" "+(width_current/scale)+" "+(height_current/scale)
    return( svg._last_viewbox );
}

function _resetViewBox(svg ) { svg.setAttribute( "viewBox", svg._ori_viewbox ); }



// Links "enrichment"

function initLinkPreview( root0, delay0 ) {

    if ( isMobile ) return;

    const scan_root   = root0 ? root0 : ( document.querySelector( "#t0" ) ? document.querySelector( "#t0" ) : document.querySelector( "#wiki" ) ); // root for where start to scan for links; specified OR default: #t0 (yes we don't want popups preview for uniprot list in extra tabs) if any, otherwise #wiki
    const delay       = delay0 ? delay0 : 300;
    const popups_root = document.getElementById( "wiki" ); // parent / root to where to add/place popups

    function hideSummaryTooltips() {
        const tts = popups_root.querySelectorAll( ".tooltip" );
        for ( const tt of tts ) { tt.classList.add( "hidden" ); }
    }

    function delayedShow( holder ) {
        hideSummaryTooltips();
        if ( !holder._has_lost_focus_during_delay ) holder.classList.remove( "hidden" );
    }

    function placeTooltip( holder, ev ) {
        const win_width  = document.documentElement.clientWidth;
        const win_height = document.documentElement.clientHeight;
        var left   = ev.clientX - 20;
        var right  = "auto";
        if ( left < 0 ) left = 0;
        var top    = ev.clientY + 10;
        var bottom = "auto";
        if ( ev.clientX / win_width > 0.5 ) { // too right, place it left of cursor
            right = win_width - ev.clientX;
            left = "auto";
        }
        if ( ev.clientY / win_height > 0.5 ) { // too low, place it on top of cursor
            bottom = win_height - ev.clientY + 20;
            top  = "auto";
        }
        holder.style.inset =    top    + ( top    === "auto" ? '' : 'px' ) + " " +
            right  + ( right  === "auto" ? '' : 'px' ) + " " +
            bottom + ( bottom === "auto" ? '' : 'px' ) + " " +
            left   + ( left   === "auto" ? '' : 'px' );
    } // p.s. cannot use older.getBoundingClientRect() as holder is not visible yet ... use/consider fixed width = 400px

    function buildHolderWithEvents( link, hcontent ) {
        const holder = document.createElement( "div" ); // build pop-up
        //holder.id = "..._"+wid;
        holder.innerHTML = hcontent
        holder.classList.add( "tooltip");
        holder.classList.add( "hidden" );
        popups_root.appendChild( holder );
        link.onmouseover = function ( ev ) { // mouse over: show summary popup (positioned next to current mouse cursor)
            placeTooltip( holder, ev );
            holder._has_lost_focus_during_delay = false;
            window.setTimeout( () => { delayedShow( holder ) }, delay );
        }
        link.onmouseout = function () { // mouse out: hide targeted element
            holder._has_lost_focus_during_delay = true;
            hideSummaryTooltips();
        }
        link.onclick = function () {
            // before click there is a mouseover event, even on mobile, (at least) on iphone (iOS 16) the popup will be shown upon clicking on the link...
            // (not a problem but) a back action will return to the page ... with the popup visible! : add onclick to remove all popups (before following the link)
            hideSummaryTooltips();
        }
    }

    if ( scan_root ) {
        const links = scan_root.querySelectorAll( "a, area" );
        for ( const link of links ) {
            const raw_href = link.getAttribute( "href" ); //.href adds http-host-port
            if ( raw_href && raw_href.startsWith( "/" ) ) { // likely internal link to another wiki
                const marray = new RegExp( /\/(?:[a-z]+\/)?(?:by(?:_|%5F)[a-z]+\/)?(\d+)(?:[\/?#].+)?/ ).exec( raw_href );
                if ( marray ) { // internal link to another wiki: add preview
                    const wid  = marray[1];
                    get( Glob.prefix+'/'+wid+".preview" ).then(
                        hsummary => {
                            if ( hsummary ) { // the wiki has some summary (json extract_html field)
                                buildHolderWithEvents( link, hsummary );
                            }
                        }
                    )
                }
            }   // e.g. used in viralzone "Human viruses and associated pathologies" 678 page
            if ( link.lang && link.lang.charAt( 0 ) === "+" ) { // simple tooltip when link has lang attribute starting with '+': hide/show existing element (by id specified after '+') fugly! should use custom data- attribute instead of looking in lang (but then lot's of wiki to change)
                const target = document.getElementById( link.lang.substr( 1 ) );
                if ( target ) {
                    target.classList.add( "tooltip");
                    target.classList.add( "hidden" );
                    link.onmouseover = function ( ev ) { // mouse over: show summary popup (positioned next to current mouse cursor)
                        placeTooltip( target, ev );
                        target._has_lost_focus_during_delay = false;
                        window.setTimeout( () => { delayedShow( target ) }, delay );
                    };
                    link.onmouseout = function () { // mouse out: hide targeted element
                        target._has_lost_focus_during_delay = true;
                        hideSummaryTooltips();
                    }
                }
            }  // e.g. used in viralzone "COVID-19 vaccines" 9696 page
            //if ( link.title && !link.title.match( / / ) ) { // protein info popup:  link has title (without space) fugly! should use custom data- attribute instead of looking in title (but then lot's of wiki to change)
            if ( raw_href && raw_href.match( /www.uniprot.org\/uniprot(?:kb)?\/[A-Z0-9]+(?:\/entry)?$/ ) ) { // protein info popup for any link to uniprot individual entry
                const pid = raw_href.match( /\/([A-Z0-9]+)(?:\/entry)?$/ )[1];
                if ( pid ) {
                    get( Glob.prefix+'/misc/protein_info_popup/'+pid ).then(
                        psummary => {
                            if ( psummary ) {
                                buildHolderWithEvents( link, psummary );
                            }
                        }
                    )
                }
            } // e.g. used in viralzone "Host G2/M cell cycle arrest by virus" 876 page
            if ( raw_href && raw_href.match( /www.rhea-db.org\/rhea\/\d+$/ ) ) { // rection popup for rhea link
                const pid = raw_href.match( /\/rhea\/(\d+)$/ )[1];
                if ( pid ) {
                    get( raw_href+"/equation" ).then(
                        reaction => {
                            buildHolderWithEvents( link, reaction );
                        }
                    )
                }
            } // e.g. in page 10163
            if ( raw_href && raw_href.includes( "wikipedia.org" ) ) { // wikipedia popup
                const preview_url = raw_href.replace( /http:/, "https:" ).replace( /wiki\//, "api/rest_v1/page/summary/" );
                get( preview_url, "", true ).then(
                    jsummary => {
                        if ( jsummary.extract_html ) { // the wiki has some summary (json extract_html field)
                            var html = jsummary.extract_html;
                            if ( jsummary.thumbnail && jsummary.thumbnail.source ) {
                                html += "\n<aside><img src=\""+jsummary.thumbnail.source+"\"/></aside>";
                            }
                            html+="\n<site>&copy; Wikipedia</site>";
                            buildHolderWithEvents( link, html );
                        }
                    }
                )
            } // e.g. used in viralzone "Kobuvirus" 652 page
        }
    }
}


// Helpers

function cleanHTML( str ) { // clean ("network content")!
    return str.replace( /<\/?script[^>]*>/gi, "" );
}



// HTTP queries ("ajax") with fetch API :


function get( path, sid, isjson ) { // XHR (via js Fetch api) GET
    return fetch( path+( sid ? ( path.includes( "?" ) ? "&" : "?" )+'sid='+sid : '' ), { cache: 'no-cache', credentials: 'omit' } ).catch(
        error => {
            console.log( "HTTP GET: fetch failed: "+error.message );
            return Promise.reject( error );
        } // CAUTION: ~>=2020 fetch send credentials (as conf "credential: same-origin" is default), so init with explicit credentials: 'omit'! (otherwise any get when logged in will be authenticated e.g. could be dangerous if checking links with side effects)
    ).then(
        response => {
            if ( response.ok ) {
                const reload = response.headers.get( 'X-Do-Reload' );
                if ( reload ) location.reload(); // do reload if "asked"
                return( isjson ? response.json() : response.text() );
            }
            else {
                let msg = response.headers.get( 'X-Message' );
                console.log( "HTTP GET: bad response; X-Message: "+msg );
                if ( msg == null ) msg = response.statusText;
                else               alert( "Error: "+msg );
                return Promise.reject( new Error( msg ) )
            }
        }
    )
} // returns Promise for text content (or json if isjson=true)


// MISC .... Datatable, Jssor (Slider) initialisation (cleaner than having inline script), PDB viewer/selector initialisation & handling
// p.s. Datatable, Jssor only works if jquery.js is loaded
// NOTE: duplicated in core.js, so each core.js & zone.js are stand-alone and independent
//       TO?DO?: keep separated (e.g. under xtra.js and have pages use core.js & xtra.js OR zone.js & xtra.js)
//               but then: CAUTION: public site run in cached mode, so as page will use new xtra.js, are src update on public sites + a release will have to be done...
//               OR have core.js & zone.js load xtra.js ?


// DataTable
function initDataTables() {
    var elems = document.querySelectorAll( '[data-is-jdata-table]' );
    for( const elem of elems ) {
        initDataTable0( elem );
    }
}

function initDataTable0( table ) {
    $(table).dataTable( { "iDisplayLength": 100 } );
}

// jssor slide shows
function initSliders() {
    var elems = document.querySelectorAll( '[data-is-slider]' );
    for( const elem of elems ) {
        initSlider0( elem.id );
    }
}

function initSlider0( cid ) {
    var _SlideshowTransitions = [
        //Fade
        { $Duration: 1200, $Opacity: 2 }
    ];

    var options = {
        $FillMode: 5,                             // 0: stretch, 1: contain (keep aspect ratio and put all inside slide), cover (keep aspect ratio and cover whole slide),4: actual size,5: contain for large image and actual size for small image

        $AutoPlay: false,                         //[Optional] Whether to auto play, to enable slideshow, this option must be set to true, default value is false
        $AutoPlaySteps: 1,                        //[Optional] Steps to go for each navigation request (this options applys only when slideshow disabled), the default value is 1
        $AutoPlayInterval: 3000,                  //[Optional] Interval (in milliseconds) to go for next slide since the previous stopped if the slider is auto playing, default value is 3000
        $PauseOnHover: 1,                         //[Optional] Whether to pause when mouse over if a slider is auto playing, 0 no pause, 1 pause for desktop, 2 pause for touch device, 3 pause for desktop and touch device, 4 freeze for desktop, 8 freeze for touch device, 12 freeze for desktop and touch device, default value is 1

        $ArrowKeyNavigation: true,                //[Optional] Allows keyboard (arrow key) navigation or not, default value is false
        $SlideDuration: 500,                      //[Optional] Specifies default duration (swipe) for slide in milliseconds, default value is 500
        $MinDragOffsetToSlide: 20,                //[Optional] Minimum drag offset to trigger slide , default value is 20
        //$SlideWidth: 600,                       //[Optional] Width of every slide in pixels, default value is width of 'slides' container
        //$SlideHeight: 300,                      //[Optional] Height of every slide in pixels, default value is height of 'slides' container
        $SlideSpacing: 0,                         //[Optional] Space between each slide in pixels, default value is 0
        $DisplayPieces: 1,                        //[Optional] Number of pieces to display (the slideshow would be disabled if the value is set to greater than 1), the default value is 1
        $ParkingPosition: 0,                      //[Optional] The offset position to park slide (this options applys only when slideshow disabled), default value is 0.
        $UISearchMode: 1,                         //[Optional] The way (0 parellel, 1 recursive, default value is 1) to search UI components (slides container, loading screen, navigator container, arrow navigator container, thumbnail navigator container etc).
        $PlayOrientation: 1,                      //[Optional] Orientation to play slide (for auto play, navigation), 1 horizental, 2 vertical, 5 horizental reverse, 6 vertical reverse, default value is 1
        $DragOrientation: 3,                      //[Optional] Orientation to drag slide, 0 no drag, 1 horizental, 2 vertical, 3 either, default value is 1 (Note that the $DragOrientation should be the same as $PlayOrientation when $DisplayPieces is greater than 1, or parking position is not 0)

        $SlideshowOptions: {                      //[Optional] Options to specify and enable slideshow or not
            $Class: $JssorSlideshowRunner$,       //[Required] Class to create instance of slideshow
            $Transitions: _SlideshowTransitions,  //[Required] An array of slideshow transitions to play slideshow
            $TransitionsOrder: 1,                 //[Optional] The way to choose transition to play slide, 1 Sequence, 0 Random
            $ShowLink: true                       //[Optional] Whether to bring slide link on top of the slider when slideshow is running, default value is false
        },

        $BulletNavigatorOptions: {                //[Optional] Options to specify and enable navigator or not
            $Class: $JssorBulletNavigator$,       //[Required] Class to create navigator instance
            $ChanceToShow: 2,                     //[Required] 0 Never, 1 Mouse Over, 2 Always
            $AutoCenter: 3,                       //[Optional] Auto center navigator in parent container, 0 None, 1 Horizontal, 2 Vertical, 3 Both, default value is 0
            $Steps: 1,                            //[Optional] Steps to go for each navigation request, default value is 1
            $Lanes: 1,                            //[Optional] Specify lanes to arrange items, default value is 1
            $SpacingX: 10,                        //[Optional] Horizontal space between each item in pixel, default value is 0
            $SpacingY: 10,                        //[Optional] Vertical space between each item in pixel, default value is 0
            $Orientation: 1                       //[Optional] The orientation of the navigator, 1 horizontal, 2 vertical, default value is 1
        },

        $ArrowNavigatorOptions: {
            $Class: $JssorArrowNavigator$,        //[Requried] Class to create arrow navigator instance
            $ChanceToShow: 1,                     //[Required] 0 Never, 1 Mouse Over, 2 Always
            $Steps: 1                             //[Optional] Steps to go for each navigation request, default value is 1
        }
    };
    new $JssorSlider$( cid, options );
}


// (Google) Charts
// n.b. google charts loader.js must be loaded

function initCharts() {
    if ( document.querySelector( ".chart" ) ) {
        google.charts.load( 'current', {'packages':[ 'corechart' ] } );
        google.charts.setOnLoadCallback( buildCharts );
    }
}

function buildCharts() {
    for ( const elem of document.querySelectorAll( ".chart" ) ) buildChart( elem );
}

//function buildChart( target ) {
//   buildColumnChart( target );
//}

function verticalTableDataExtract( table, xIsString, xIsDate ) { // extract data from table with rows = [ X1, Ya1, Yb1 ...]... into an array
    var hAxisIsFloat = false;
    // build data struct for chart
    var darray  = [];
    var nlabels = 0;
    for ( tr of table.querySelectorAll("tr" ) ) { // add data lines
        const isLabelLine = darray.length === 0;
        var tds = [];
        for ( td of tr.querySelectorAll("td, th" ) ) {
            if ( isLabelLine ) { nlabels++; tds.push( td.textContent ); }
            else {
                const isX    = !tds.length && !isLabelLine;
                const nvalue = td.textContent.replace( /,/g, '' );
                if ( isX && !xIsString && !xIsDate && !isNaN(nvalue) && nvalue.includes('.') ) hAxisIsFloat = true;
                if ( isX && ( isNaN(nvalue) || xIsString ) ) tds.push( td.textContent ); // if not a number or should-be-string (e.g. for pie chart): parse 1st column (X axis) as string
                else tds.push( parseFloat( nvalue ) ); // any other cases: parse as float
            }
        }
        if ( tds.length < nlabels ) { // add missing column! in case table is malformed!
            const n_missing = nlabels - tds.length;
            for (let i = 0; i < n_missing; i++) tds.push(NaN);
        }
        darray.push(tds);
    }
    return( { darray: darray, hAxisIsFloat: hAxisIsFloat } );
}

function horizontalTableDataExtract( table, xIsString, xIsDate ) { // extract data from table with columns = [ X1, Ya1, Yb1 ...]... into an array
    var hAxisIsFloat = false;
    // build data struct for chart
    var darray  = [];
    var nlabels = 0;
    const trs  = table.querySelectorAll( "tr" );
    const ncol = trs[0].querySelectorAll("td, th" ).length;
    for ( let i = 0; i < ncol; i++ ) {
        const isLabel = i === 0;
        var column = [];
        for ( tr of trs ) {
            const isX = !isLabel && column.length === 0;
            const td  = tr.querySelectorAll("td, th")[i];
            if ( td ) {
                if ( isLabel ) column.push( td.textContent );
                else {
                    const nvalue = td.textContent.replace( /,/g, '' );
                    if ( isX && !xIsString && !xIsDate && !isNaN(nvalue) && nvalue.includes('.') ) hAxisIsFloat = true;
                    if ( isX && xIsDate ) {
                        const dstr = td.textContent.replace( /\./g,'-').replace( /(\d{2})-(\d{4})/, '$2-$1' ).replace( /(\d{2})-(\d{2})-(\d{4})/, '$3-$2-$1' );
                        column.push( new Date( dstr ) );
                    }
                    else if ( isX && ( isNaN(nvalue) || xIsString ) ) column.push( td.textContent );
                    else column.push( parseFloat( nvalue ) );
                }
            }
            else column.push( NaN );
        }
        darray.push(column);
    }
    return( { darray: darray, hAxisIsFloat: hAxisIsFloat } );
}

function buildChart( target ) { // build chart, so far based on inner table content, type: column/bar (default), pie, line/curve/timeSeries
    const table     = target.querySelector( "table" );
    const xIsString = target.getAttribute( "data-type" ) === "pie";
    const xIsDate   = target.getAttribute( "data-type" ) === "timeSeries";
    const colIsXY   = target.getAttribute( "data-orientation" ) === "horizontal" || target.getAttribute( "data-type" ) === "geo";
    const { darray, hAxisIsFloat } = table ? (
        colIsXY ?
            horizontalTableDataExtract( table, xIsString, xIsDate ) :
            verticalTableDataExtract(   table, xIsString, xIsDate ) // classical & matching gchart data orientation (lines are XY...)
    ) : { darray: [], hAxisIsFloat: false };
    const labels = darray[0];
    const data   = google.visualization.arrayToDataTable( darray );
    // build chart container (div)
    const container = document.createElement( "div" );
    if ( table ) target.removeChild( table );
    target.appendChild( container );
    // draw chart
    const options = {
        title:  target.getAttribute( "data-title" )  ? target.getAttribute( "data-title" ) : "...",
        width:  target.getAttribute( "data-width" )  ? parseInt( target.getAttribute( "data-width" ) )  : 600,
        height: target.getAttribute( "data-height" ) ? parseInt( target.getAttribute( "data-height" ) ) : 450,
        bar:  { groupWidth: '40%' },
        hAxis: {},
        vAxis: {}
    };
    const isXY = labels.length === 2;
    options.hAxis.format = hAxisIsFloat || xIsDate ? null : "#";  // if horiz axis is not float (and not time); display its values as plain number [if a number] without ,. formatting (in case it's a year)
    options.hAxis.title  = labels[0];
    options.vAxis.title  = isXY ? labels[1] : ''; // vertical axis title = label for col2 if data has 2 columns (XY) (otherwise: no vtitle; legend should be used)
    options.legend       = isXY && target.getAttribute( "data-type" ) !== "pie" ? 'none' : null; // no legend for 2 columns data (XY) unless type is pie
    var chart;
    switch ( target.getAttribute( "data-type" ) ) {
        case "pie" :
            chart = new google.visualization.PieChart( container );
            break;
        case "curve" :
            options.curveType = "function";
        case "line" :
        case "timeSeries" :
            if ( darray.length < 21 ) options.pointSize = "5";
            chart = new google.visualization.LineChart( container );
            break;
        case "geo" :
            options.backgroundColor = '#E0EFFF';
            options.defaultColor    = '#F40';
            chart  = new google.visualization.GeoChart( container );
            break;
        default: // for bar = column charts
            chart = new google.visualization.ColumnChart( container );
    }
    chart.draw( data, options );
}


// PDB (pdbe-molstar)

function initPDBs() {
    // scan for any elem with attribute data-pdb ...
    var elems = document.querySelectorAll( '[data-pdb]' );
    for( const elem of elems ) {
        initPDB( elem );
    }
    initPDBSelects();
}

function initPDB( container ) {
    // for div with attribute data-pdb: create PDBeMolstar viewer showing specified pdb
    // format: data-pdb=<pdbid>
    if ( typeof PDBeMolstarPlugin !== 'undefined' ) {
        var viewer = new PDBeMolstarPlugin();
        var options = {
            visualStyle: 'cartoon',
            lighting: 'glossy',
            expanded: false,
            hideControls: true
        };
        options.moleculeId = container.getAttribute( "data-pdb" ).toLowerCase();
        viewer.render( container, options );
        const color = container.getAttribute( "data-bgcolor" ) ? container.getAttribute( "data-bgcolor" ).toLowerCase() : "";
        if ( color === "white" ) viewer.canvas.setBgColor( { r:255, g:255, b:255 } );
        container._viewer = viewer;
    }
}
// see https://github.com/PDBeurope/pdbe-molstar/wiki/1.-PDBe-Molstar-as-JS-plugin
//     https://github.com/PDBeurope/pdbe-molstar/wiki/3.-Helper-Methods


function initPDBSelects() {
    // scan for any elem with attribute data-target-pdb ...
    var elems = document.querySelectorAll( '[data-target-pdb]' );
    for( const elem of elems ) {
        initPDBSelect( elem, elems );
    }
}

function initPDBSelect( elem, elems ) {
    // for elem with attribute data-target-pdb
    // add event handler to select specified position range in pdb
    // format: data-target-pdb="<pdbid>|<chain>:<start>[-<stop>][,...]" )
    const params = elem.getAttribute( "data-target-pdb" ).split( '\|' );
    const target = params[0].split(':')[0];
    const pdb_container = document.querySelector( '[data-pdb="'+target+'"]' );
    if ( pdb_container ) {
        const selects = params[1].split(',');
        var   vranges = []; // /n.b. ... closure: vranges is in context for elem event handler = will be accessible in event handler
        for ( const select of selects ) { // create data structure for viewer selection "ranges"
            const selems = select.split( ':' );
            const chain  = selems[0];
            const range  = selems[1].split('-');
            const start  = parseInt( range[0] );
            const stop   = range[1] ? parseInt( range[1] ) : start;
            if ( start === stop ) vranges.push( { entity_id: '1', struct_asym_id: chain, residue_number: start,                                 color:{r:255,g:20,b:20}, representationColor:{r:255,g:20,b:20}, representation: 'molecular-surface', focus: false } );
            else                  vranges.push( { entity_id: '1', struct_asym_id: chain, start_residue_number: start, end_residue_number: stop, color:{r:255,g:20,b:20}, representationColor:{r:255,g:20,b:20}, representation: 'molecular-surface', focus: false } );
        }
        elem.addEventListener( 'click', // add onclick on selector (that will select requested range(s) on target pdb
            function( ev ) {
                ev.preventDefault();
                const focus = !!ev.shiftKey;
                if ( elem.classList.contains( 'pdbselect' ) ) {
                    for ( const e of elems ) e.classList.remove( 'pdbselect' );
                    pdb_container._viewer.visual.clearSelection();
                }
                else {
                    for ( const e of elems ) e.classList.remove( 'pdbselect' );
                    elem.classList.add( 'pdbselect' );
                    for ( vrange of vranges ) vrange.focus = focus;
                    //pdb_container._viewer.visual.clearSelection();
                    pdb_container._viewer.visual.select( { data: vranges, nonSelectedColor: {r:80,g:80,b:120} } );
                }
            }
        )
    }
}
